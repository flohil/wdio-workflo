<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Page · Wdio-Workflo</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;h2&gt;&lt;a class=&quot;anchor&quot; aria-hidden=&quot;true&quot; id=&quot;overview-and-objective&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#overview-and-objective&quot; aria-hidden=&quot;true&quot; class=&quot;hash-link&quot;&gt;&lt;svg class=&quot;hash-link-icon&quot; aria-hidden=&quot;true&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Overview and Objective&lt;/h2&gt;
"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Page · Wdio-Workflo"/><meta property="og:type" content="website"/><meta property="og:url" content="https://flohil.github.io/wdio-workflo/index.html"/><meta property="og:description" content="&lt;h2&gt;&lt;a class=&quot;anchor&quot; aria-hidden=&quot;true&quot; id=&quot;overview-and-objective&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#overview-and-objective&quot; aria-hidden=&quot;true&quot; class=&quot;hash-link&quot;&gt;&lt;svg class=&quot;hash-link-icon&quot; aria-hidden=&quot;true&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Overview and Objective&lt;/h2&gt;
"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/wdio-workflo/img/favicon.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/rainbow.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><link rel="stylesheet" href="/wdio-workflo/css/main.css"/><script src="/wdio-workflo/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/wdio-workflo/"><img class="logo" src="/wdio-workflo/img/logo.svg" alt="Wdio-Workflo"/><h2 class="headerTitleWithLogo">Wdio-Workflo</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/wdio-workflo/docs/setup" target="_self">Guides</a></li><li class=""><a href="/wdio-workflo/demo" target="_self">Demo Page</a></li><li class=""><a href="https://github.com/flohil/wdio-workflo-example" target="_self">Examples</a></li><li class=""><a href="/wdio-workflo/apiDoc" target="_self">API</a></li><li class=""><a href="https://github.com/flohil/wdio-workflo" target="_self">Github</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Page Objects</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Getting Started</h3><ul class=""><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/setup">Setup</a></li><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/firstTest">Writing your first Test</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Configuration</h3><ul class=""><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/config">Configuration Options</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Architecture</h3><ul class=""><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/classes">Class Diagram</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Specs</h3><ul class=""><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/specs">Specs</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Page Objects</h3><ul class=""><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/pageObjects">Page Objects</a></li><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/element">Element</a></li><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/list">List</a></li><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/map">Map</a></li><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/group">Group</a></li><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/store">Store</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/wdio-workflo/docs/page">Page</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Steps</h3><ul class=""><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/steps">Steps</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Testcases</h3><ul class=""><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/testcases">Testcases</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Customizing Page Nodes</h3><ul class=""><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/customPageNodes">Introduction</a></li><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/customElement">Customizing an Element</a></li><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/customList">Customizing a List</a></li><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/customMap">Customizing a Map</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Various Tools</h3><ul class=""><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/xpathBuilder">XPath Builder</a></li><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/getUid">The `getUid` Function</a></li><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/executionLists">Execution Lists</a></li><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/manualResults">Manual Results</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Testrunner</h3><ul class=""><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/cliOptions">CLI Options</a></li><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/runningTests">Running Tests</a></li><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/debugging">Debugging</a></li><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/reporters">Reporters</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">Page</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" id="overview-and-objective"></a><a href="#overview-and-objective" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Overview and Objective</h2>
<p>The objective of a <code>Page</code> is to map the structure of a website. It is essentially an
aggregation of all <code>PageNode</code> instances that make up a complete website or a large fragment
of a website. In order to create these <code>PageNode</code> instances, each <code>Page</code> has an instance of
a <code>PageNodeStore</code> class associated with it that is available via its <code>_store</code> class member.</p>
<p>Pages allow us to assign meaningful names to the page nodes in its scope. They also
define XPath selectors to locate these page nodes in the DOM. Since page nodes usually always
live within the scope of a <code>Page</code>, pages act as interfaces for testcases who want to access
a certain page node in order to interact with its corresponding HTML elements on a website.</p>
<p>Finally, each <code>Page</code> needs to implement two life cycle methods, <code>isOpen</code> and <code>isClosed</code>,
to indicate whether a page is fully loaded or not. These life cycle methods come in handy
when a single testcase interacts with more than one page and needs to switch pages.</p>
<h2><a class="anchor" aria-hidden="true" id="location-and-naming-convention"></a><a href="#location-and-naming-convention" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Location and Naming Convention</h2>
<p>Page files are located in the <code>src/page_objects/pages</code> folder of your system test
directory. I usually like to name page classes so that they end with the term 'Page'
but from a technical perspective, this is not required and you do not need to follow
this convention.</p>
<h2><a class="anchor" aria-hidden="true" id="code-example"></a><a href="#code-example" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Code Example</h2>
<p>The following sections of this page guide often refer to code snippets taken
from the <code>BasePage</code> class which is located at <code>src/page_objects/pages/BasePage.ts</code>
in the wdio-workflo-example repository.</p>
<p>This base class implements some common functionality for all pages of our
web application.</p>
<p>Here is the complete <code>BasePage.ts</code> file for a better overview:</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">import</span> { stores } <span class="hljs-keyword">from</span> <span class="hljs-string">'?/page_objects'</span>;
<span class="hljs-keyword">import</span> { Page, IPageOpts } <span class="hljs-keyword">from</span> <span class="hljs-string">'./Page'</span>;

<span class="hljs-keyword">import</span> { workfloConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">'~/workflo.conf'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IBasePageOpts&lt;
  Store <span class="hljs-keyword">extends</span> stores.PageNodeStore
&gt; <span class="hljs-keyword">extends</span> IPageOpts&lt;Store&gt; {
  pageName: DemoApp.PageName;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> BasePage&lt;
  Store <span class="hljs-keyword">extends</span> stores.PageNodeStore
&gt; <span class="hljs-keyword">extends</span> Page&lt;Store&gt; {
  pageName: DemoApp.PageName;

  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">opts: IBasePageOpts&lt;Store&gt;</span>) {
    <span class="hljs-keyword">const</span> { pageName, ...superOpts } = opts;
    <span class="hljs-keyword">super</span>(superOpts);

    <span class="hljs-keyword">this</span>.pageName = pageName;
  }

  <span class="hljs-keyword">get</span> container() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._store.Element(
      xpath(<span class="hljs-string">'//main'</span>),
    );
  }

  <span class="hljs-keyword">get</span> heading() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.container.$.Element(
      xpath(<span class="hljs-string">'//h1'</span>)
    );
  }

  <span class="hljs-comment">// check if pathname section of current browser url starts with our page's name</span>
  <span class="hljs-keyword">private</span> _doesUrlMatchPageName() {
    <span class="hljs-keyword">const</span> pathName = browser.getUrl().replace(workfloConfig.baseUrl, <span class="hljs-string">''</span>);

    <span class="hljs-comment">// we need to double escape backslashes because they are interpreted as a string first</span>
    <span class="hljs-keyword">const</span> pageNameRegex = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">`^\\/<span class="hljs-subst">${this.pageName}</span>(\\?|\\/)*`</span>);

    <span class="hljs-keyword">return</span> pageNameRegex.test(pathName);
  }

  isOpen(): <span class="hljs-built_in">boolean</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._doesUrlMatchPageName() &amp;&amp;
      <span class="hljs-keyword">this</span>.heading.currently.isVisible() &amp;&amp;
      <span class="hljs-keyword">this</span>.heading.currently.getText().toLowerCase() === <span class="hljs-keyword">this</span>.pageName;
  }

  isClosed(): <span class="hljs-built_in">boolean</span> {
    <span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>._doesUrlMatchPageName() ||
      <span class="hljs-keyword">this</span>.heading.currently.not.isVisible() ||
      <span class="hljs-keyword">this</span>.heading.currently.getText().toLowerCase() !== <span class="hljs-keyword">this</span>.pageName;
  }
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="structure"></a><a href="#structure" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Structure</h2>
<h3><a class="anchor" aria-hidden="true" id="typing-and-constructor"></a><a href="#typing-and-constructor" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Typing and Constructor</h3>
<p>At the top of a page file, we need to declare the type of our page's <code>opts</code>
parameter as interface, define the page's class and type parameters and implement
its constructor:</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IBasePageOpts&lt;
  Store <span class="hljs-keyword">extends</span> stores.PageNodeStore
&gt; <span class="hljs-keyword">extends</span> IPageOpts&lt;Store&gt; {
  pageName: DemoApp.PageName;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> BasePage&lt;
  Store <span class="hljs-keyword">extends</span> stores.PageNodeStore
&gt; <span class="hljs-keyword">extends</span> Page&lt;Store&gt; {
  pageName: DemoApp.PageName;

  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">opts: IBasePageOpts&lt;Store&gt;</span>) {
    <span class="hljs-keyword">const</span> { pageName, ...superOpts } = opts;
    <span class="hljs-keyword">super</span>(superOpts);

    <span class="hljs-keyword">this</span>.pageName = pageName;
  }

  <span class="hljs-comment">/*...*/</span>
}
</code></pre>
<p>In our code example, we implement <code>BasePage</code> as an <code>abstract</code> class that cannot live on
its own but needs to be extended by all (or most) normal page classes of our web application.</p>
<p>Each page of our web application has a <code>pageName</code>. By appending this <code>pageName</code> to the
base url of our web application, we can navigate to the corresponding page if we enter
the combined URL into the address bar of a browser.</p>
<p>So, to declare the type of our page's <code>opts</code> parameter, we extend <code>IBasePageOpts</code> from
wdio-workflo's <code>IPageOpts</code> interface and add our additional <code>pageName</code> property.
The <code>pageName</code> property is of the type <code>DemoApp.PageName</code> which is a list of
string literals containing the names of all the pages of our web application:</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">namespace</span> DemoApp {
  <span class="hljs-keyword">type</span> PageName = <span class="hljs-string">'feed'</span> | <span class="hljs-string">'registration'</span>
}
</code></pre>
<p>Then we extend our <code>BasePage</code> class from wdio-workflo's <code>Page</code> class and declare it
to be <code>abstract</code> since it only serves as a common base class that should be extended
by all other page classes of our web application.</p>
<p>Both wdio-workflo's <code>Page</code> class and its <code>IPageOpts</code> interface require us to define
one type parameter: the type of the <code>PageNodeStore</code> associated with the page.
For our base class, however, we don't want to define a specific store class,
because each page extending it could be associated with a different store. Therefore,
our <code>BasePage</code> class and its <code>IBasePageOpts</code> use a generic <code>Store</code> type and they themselves require you
to define this <code>Store</code> type as a type parameter in all page classes that extend our <code>BasePage</code> class.</p>
<p>This may sound a little complicated, but I think the following example explains
how a normal page class can be extended from our <code>BasePage</code> class:</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">import</span> { stores } <span class="hljs-keyword">from</span> <span class="hljs-string">'?/page_objects'</span>;

<span class="hljs-keyword">import</span> { BasePage } <span class="hljs-keyword">from</span> <span class="hljs-string">'../BasePage'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> FeedPage <span class="hljs-keyword">extends</span> BasePage&lt;stores.FeedStore&gt; {

  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">super</span>({
      store: stores.feeds,
      pageName: <span class="hljs-string">'feed'</span>
    });
  }

  <span class="hljs-comment">/*...*/</span>
}
</code></pre>
<p>As you can see, the <code>FeedPage</code> class which extends our <code>BasePage</code> class defines
the generic <code>Store</code> type parameter of our <code>BasePage</code> (the type of the <code>PageNodeStore</code>
associated with <code>FeedPage</code>) to be <code>stores.FeedStore</code>.</p>
<p>In its constructor, <code>FeedPage</code> sets the value of the <code>store</code> property of <code>BasePage</code>'s <code>opts</code> parameter
to <code>stores.feeds</code> and the value of its <code>pageName</code> property to <code>'feed'</code>.</p>
<h3><a class="anchor" aria-hidden="true" id="defining-page-nodes"></a><a href="#defining-page-nodes" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Defining Page Nodes</h3>
<h4><a class="anchor" aria-hidden="true" id="quick-instructions"></a><a href="#quick-instructions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Quick Instructions</h4>
<p>As already mentioned, the main objective of a <code>Page</code> is to map the structure of a website.
To do so, we need to define a class property for each <code>PageNode</code> that resides within the page's scope.</p>
<p>Wdio-workflo wants you to define these page node properties using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get">getter functions</a>
to ensure that the HTML elements mapped by a page node are located again on the
website and fetched each time we invoke the state interaction functions of a page node
(e.g. <code>getText</code>, <code>click</code>...).</p>
<p>A common scenario for a page is to have a <code>container</code> page node that wraps all other
content of the page. The following code example shows you how to define a property
for the <code>container</code> page node on the <code>BasePage</code> class using a getter function:</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">class</span> BasePage {
  <span class="hljs-keyword">get</span> container() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._store.Element(
      xpath(<span class="hljs-string">'//main'</span>),
    );
  }
}
</code></pre>
<p>As you can see, we define our <code>container</code> class property using the <code>get</code> keyword.
We then access the <code>PageNodeStore</code> instance associated with our <code>BasePage</code> class
via <code>this._store</code> and invoke the store's <code>Element()</code> <a href="/wdio-workflo/docs/store##factory-methods">factory method</a>
to obtain an instance of a <code>PageElement</code> class for our <code>container</code> element.</p>
<p>The <code>Element()</code> factory method requires us to pass an XPath selector for our <code>PageElement</code>
that locates the HTML element corresponding to our <code>container</code> on the website. To define an
XPath selector, you can either write a &quot;raw XPath string&quot;, or you can use wdio-workflo's
<a href="/wdio-workflo/docs/xpathBuilder">XPath builder</a> that facilitates writing complex XPath selectors, like
in our code example above.</p>
<p><em>Please be aware that wdio-workflo only supports XPath selectors and no CSS selectors
because XPath selectors are more &quot;flexible&quot; than CSS selectors
(they support searching for a parent element) and because the performance differences
between XPath selector and CSS selectors are negligible in most cases.</em></p>
<p>Typically, if your page has a <code>container</code> page node, all other page nodes will
want to prepend the XPath selector of the <code>container</code> to their own. To do so, the other
page nodes can use the <code>$</code> accessor of the <code>container</code> page node which returns
the <code>PageNodeStore</code> associated with the <code>container</code> and prepends the XPath selector
of the <code>container</code> page node automatically when invoking a factory method via its <code>$</code> accessor:</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">class</span> RegistrationPage <span class="hljs-keyword">extends</span> BasePage&lt;stores.PageNodeStore&gt; {
  <span class="hljs-keyword">get</span> submitButton() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.container.$.Element(
      xpath(<span class="hljs-string">'//button'</span>).text(<span class="hljs-string">'Submit'</span>)
    );
  }
}
</code></pre>
<p>In the code example above, the combined XPath selector of the <code>submitButton</code> element
would be <code>&quot;//main//button[.='Submit']&quot;</code>.</p>
<p>If you can live with the fact that when writing tests in wdio-workflo, by convention,
page nodes are defined within the scope of a page using getter functions,
you can skip the rest of this chapter.</p>
<p>However, if you'd like to learn why wdio-workflo urges you to use getter functions
to define page nodes on a page, please keep on reading the following sections of this chapter!</p>
<h4><a class="anchor" aria-hidden="true" id="pages-and-page-nodes-are-stateless"></a><a href="#pages-and-page-nodes-are-stateless" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Pages and Page Nodes are Stateless</h4>
<p>When dealing with pages, you need you to realize an important concept: Pages are stateless!</p>
<p>Neither a page, nor any of the page nodes defined within its scope, store information
about the state of the GUI they represent. Instead, all of the information about the GUI's state
is stored within the GUI itself. Actually, the GUI's whole purpose is to display the state of the
tested application in a user-friendly way. Therefore, there is no difference between the GUI and
the GUI's state - they are the same.</p>
<p>If we want to retrieve information about the state of the GUI, we need to invoke one of a
page node's state retrieval functions, e.g. <code>getText()</code>. Each state retrieval function
first needs to locate the HTML elements mapped by a page node on the website before it can
read their state. And it needs to do so every time it is invoked, because modern web applications
are dynamic and their content/the HTML elements displayed on their websites
can change quite often. This is particularly true in the case of single page applications
(SPAs), which technically consist of only one single HTML website (typically index.html)
and whose content is changed via JavaScript DOM manipulation to display different views/pages.</p>
<p>Let's take wdio-workflo's demo application as an example. It has a feed and a registration
page which are both displayed by the same index.html file. The feed page also has
a textfield that filters the displayed feed items by their title.
If we do not enter a term to filter our feed items, the first item displayed in the
feed is a dog. If we filter by the term 'ca', the first item displayed in the feed
becomes a cat:</p>
<p><img src="/wdio-workflo/docs/assets/feed_no_filter.png" alt="no filter for feed items">
<img src="/wdio-workflo/docs/assets/feed_cat_filter.png" alt="'ca' filter for feed items"></p>
<p>Now to test if our feed filter is working correctly, we want to retrieve the text
of the first feed item's title before and after entering the term 'ca' into our textfield.
This will only work if the underlying HTML element is located again on the website each time
we invoke <code>getText()</code> on it's corresponding page node. Otherwise, after entering the term
'ca' into the textfield, we would either still receive the previous title's text (&quot;Dog&quot;)
or a <a href="https://www.seleniumhq.org/exceptions/stale_element_reference.jsp">stale element error</a>
would occur because the HTML element containing the text &quot;Dog&quot; no longer exists on the website.</p>
<h4><a class="anchor" aria-hidden="true" id="defining-page-nodes-using-javascript-getters"></a><a href="#defining-page-nodes-using-javascript-getters" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Defining Page Nodes using JavaScript Getters</h4>
<p>To quote <a href="http://v4.webdriver.io/guide/testrunner/pageobjects.html">webdriverio's docs</a>,
getter functions get evaluated when you actually access the property (<code>container</code>) and not when you
generate the object (the surrounding <code>BasePage</code> class).
With that you always request the element (from the website) before you do an action on it:</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">class</span> BasePage {
  <span class="hljs-keyword">get</span> container() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._store.Element(
      xpath(<span class="hljs-string">'//main'</span>),
    );
  }
}
</code></pre>
<p>Before I'll show you what would happen if we did not use JavaScript getters to define our page nodes,
let's remember that each <code>PageNode</code> class is essentially an additional layer of abstraction
that wraps the commands provided by webdriverio's <code>browser</code> object. Taking our feed items from above
as an example, if we fetch an instance of <code>FeedItemList</code> from a store and call the <code>getText</code>
function on the <code>title</code> subelement of the first feed item, wdio-workflo internally invokes the
corresponding webdriverio commands:</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">this</span>.container.$.FeedItemList(
  xpath(<span class="hljs-string">'//div'</span>).attribute(<span class="hljs-string">'role'</span>, <span class="hljs-string">'listitem'</span>).hasChild(
    <span class="hljs-string">'//div'</span>, <span class="hljs-function"><span class="hljs-params">xpath</span> =&gt;</span> xpath.classContains(<span class="hljs-string">'Feed-itemCell'</span>)
  ),
).first.title.getText();

<span class="hljs-comment">/*internally invokes*/</span>

browser.element(
  <span class="hljs-string">"//div[@role='listitem'][.//div[contains(@class,'Feed-itemCell')]]//div[contains(@class,'Feed-itemName')]"</span>
).getText();
</code></pre>
<p>The <code>element</code> command defined on webdriverio's <code>browser</code> object tries to locate
an HTML element on a website using the provided selector and fetches the first found
element on the page. You can then invoke other commands like <code>getText</code> on the fetched
element to interact with the located HTML element.</p>
<p>For the sake of simplicity, let's assume that our feed page has only one property
called <code>firstFeedItemTitle</code> which we fetch from the website using webdriverio's <code>element</code>
command directly, skipping the additional <code>PageNode</code> abstraction layer.</p>
<p>Let us now compare two different ways of defining our <code>firstFeedItemTitle</code> property
within the scope of the <code>FeedPage</code>:</p>
<ul>
<li>As a &quot;normal&quot; class property (don't do this!)</li>
<li>Using a getter function</li>
</ul>
<p>Take a look at this code example:</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">class</span> FeedPage {
  <span class="hljs-comment">// Variant A: a "normal" class property</span>
  firstFeedItemTitle = browser.element(
    <span class="hljs-string">"//div[@role='listitem'][.//div[contains(@class,'Feed-itemCell')]]//div[contains(@class,'Feed-itemName')]"</span>
  )

  <span class="hljs-comment">/*or*/</span>

  <span class="hljs-comment">// Variant B: using a getter function</span>
  <span class="hljs-keyword">get</span> firstFeedItemTitle() {
    <span class="hljs-keyword">return</span> browser.element(
      <span class="hljs-string">"//div[@role='listitem'][.//div[contains(@class,'Feed-itemCell')]]//div[contains(@class,'Feed-itemName')]"</span>
    )
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> feed = <span class="hljs-keyword">new</span> FeedPage();
</code></pre>
<p>To observe how these two variants of defining <code>firstFeedItemTitle</code> would lead to a
different outcome, let's examine the following little testcase that validates our feed's filtering behavior
by comparing the title of the first feed item before and after filtering the list using the term &quot;ca&quot;:</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">import</span> { pages } <span class="hljs-keyword">from</span> <span class="hljs-string">'?/page_objects'</span>;
<span class="hljs-keyword">import</span> { steps } <span class="hljs-keyword">from</span> <span class="hljs-string">'?/steps'</span>;

testcase(<span class="hljs-string">"feed filtering"</span>, {}, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  given(steps[<span class="hljs-string">"open demo website"</span>]())
  .and(steps[<span class="hljs-string">"open page '%{page}'"</span>]({
    args: { page: pages.feed },
    cb: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      validate({ <span class="hljs-string">"0.1"</span>: [<span class="hljs-number">1</span>] }, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-keyword">const</span> titleBeforeFiltering = pages.feed.firstFeedItemTitle.getText()

        expect(titleBeforeFiltering).toEqual(<span class="hljs-string">'Dog'</span>)
      });
    }
  }))
  .when(steps[<span class="hljs-string">"filter feed items by term %{term}"</span>]({
    args: { term: <span class="hljs-string">'ca'</span> },
    cb: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      validate({ <span class="hljs-string">"0.1"</span>: [<span class="hljs-number">2</span>] }, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-keyword">const</span> titleAfterFiltering = pages.feed.firstFeedItemTitle.getText()

        expect(titleAfterFiltering).toEqual(<span class="hljs-string">'Cat'</span>)
      });
    }
  }));
})
</code></pre>
<p>As you can see, our testcase needs to access our <code>firstFeedItemTitle</code> property
and call <code>getText()</code> on it two times: before and after filtering the feed items list.</p>
<p>In order for our testcase to behave as expected and return a different text before
and after filtering, the HTML element containing the text of the
first feed item's title needs to be fetched from the website each time we invoke the
<code>getText</code> function. This is exactly what happens if we defined <code>firstFeedItemTitle</code>
like variant B, using a getter function because getter functions are reevaluated
each time we access them. In fact, a getter function could also be written as a normal
function, but in this case, we would have to use function parenthesis and name
our class property like a method, e.g. <code>getFirstFeedItemTitle()</code>, which does
not look as nice:</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">class</span> FeedPage {
  getFirstFeedItemTitle() {
    <span class="hljs-keyword">return</span> browser.element(
      <span class="hljs-string">"//div[@role='listitem'][.//div[contains(@class,'Feed-itemCell')]]//div[contains(@class,'Feed-itemName')]"</span>
    )
  }
}

<span class="hljs-keyword">const</span> feed = <span class="hljs-keyword">new</span> FeedPage()

feed.getFirstFeedItemTitle().getText()
</code></pre>
<p>But what about variant A, defining <code>firstFeedItemTitle</code> as a &quot;normal&quot; class property,
without using a getter function? In this case, <code>firstFeedItemTitle</code> would be evaluated
only one time, when our <code>FeedPage</code> class gets instantiated. This would also mean that
the HTML element containing the text of the first feed item's title would be located and fetched
on the page only once to set the value of <code>firstFeedItemTitle</code>.</p>
<p>So what's the problem with that? If you look at our testcase code example closely,
you will notice that our <code>FeedPage</code> instance is stored in <code>pages.feed</code> and that the
<code>pages</code> object gets imported on the first line of our testcase file.
However, the step that opens our feed page, <code>steps[&quot;open page '%{page}'&quot;]</code>, occurs several lines later.
This means that wdio-workflo will not be able to locate the HTML element described by the selector of
<code>firstFeedItemTitle</code> because the feed page which contains this HTML element is not even loaded yet.</p>
<p>Fetching <code>firstFeedItemTitle</code> via the <code>browser.element</code> command would return a <code>NoSuchElement</code> result:</p>
<p><img src="/wdio-workflo/docs/assets/noSuchElement.png" alt="no such element"></p>
<p>As you can imagine, calling functions like <code>getText</code> or <code>click</code> on an element that could
not be located on the website will not work and cause your testcase to break, fail or behave unexpectedly.</p>
<p>After this rather long and detailed explanation, I hope you now understand why wdio-workflo
urges you to define page nodes using getter functions by convention.</p>
<h3><a class="anchor" aria-hidden="true" id="implementing-lifecycle-methods"></a><a href="#implementing-lifecycle-methods" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Implementing &quot;LifeCycle&quot; Methods</h3>
<h4><a class="anchor" aria-hidden="true" id="implementing-isopen-and-isclosed"></a><a href="#implementing-isopen-and-isclosed" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Implementing <code>isOpen</code> and <code>isClosed</code></h4>
<p>Each page derived from wdio-workflo's <code>Page</code> class requires you to implement the
methods <code>isOpen</code> and <code>isClosed</code>. If a page is currently fully loaded, <code>isOpen</code> is
supposed to return true and otherwise to return false. For <code>isClosed</code> it is the exact opposite.</p>
<p>These methods are typically invoked whenever you need to switch pages in your tested
application. They are meant to ensure that a page change has been fully completed
before the execution of a testcase resumes.</p>
<p>To check if the new page has been fully loaded, you usually check if a certain
element of the new page (e.g. a header) has already been rendered. If your app uses
URL routing, you should also make sure that the URL has changed in the browser's
address bar.</p>
<p>This code example shows the <code>BasePage</code> class' implementation of <code>isOpen</code> and <code>isClosed</code>:</p>
<pre><code class="hljs css language-typescript"><span class="hljs-comment">// check if pathname section of current browser url starts with our page's name</span>
<span class="hljs-keyword">private</span> _doesUrlMatchPageName() {
  <span class="hljs-keyword">const</span> pathName = browser.getUrl().replace(workfloConfig.baseUrl, <span class="hljs-string">''</span>);

  <span class="hljs-comment">// we need to double escape backslashes because they are interpreted as a string first</span>
  <span class="hljs-keyword">const</span> pageNameRegex = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">`^\\/<span class="hljs-subst">${this.pageName}</span>(\\?|\\/)*`</span>);

  <span class="hljs-keyword">return</span> pageNameRegex.test(pathName);
}

isOpen(): <span class="hljs-built_in">boolean</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._doesUrlMatchPageName() &amp;&amp;
    <span class="hljs-keyword">this</span>.heading.currently.isVisible() &amp;&amp;
    <span class="hljs-keyword">this</span>.heading.currently.getText().toLowerCase() === <span class="hljs-keyword">this</span>.pageName;
}

isClosed(): <span class="hljs-built_in">boolean</span> {
  <span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>._doesUrlMatchPageName() ||
    <span class="hljs-keyword">this</span>.heading.currently.not.isVisible() ||
    <span class="hljs-keyword">this</span>.heading.currently.getText().toLowerCase() !== <span class="hljs-keyword">this</span>.pageName;
}
</code></pre>
<p>Similar to the classes of the <code>PageNode</code> family, each <code>Page</code> class also has
a <code>wait</code> and an <code>eventually</code> API. The <code>wait.isOpen</code>, <code>wait.isClosed</code>, <code>eventually.isOpen</code>
and <code>eventually.isClosed</code> functions will periodically invoke your <code>isOpen</code> and <code>isClosed</code>
implementations until their condition returns true or until a specific timeout has been reached.</p>
<p>However, since pages, unlike page nodes, do not perform implicit waiting,
pages do not have a <code>currently</code> API. Instead, all methods defined directly
on a <code>Page</code> class (like <code>isOpen</code> and <code>isClosed</code>) always reflect the current state of the GUI.</p>
<h4><a class="anchor" aria-hidden="true" id="defining-parameter-objects-for-isopen-and-isclosed"></a><a href="#defining-parameter-objects-for-isopen-and-isclosed" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Defining Parameter Objects for <code>isOpen</code> and <code>isClosed</code></h4>
<p>You can also pass a parameters object to your <code>isOpen</code> and <code>isClosed</code> functions.
The types of these parameters objects can be set via the second and third type parameters
of the <code>Page</code> class:</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">interface</span> IIsOpenOpts {
  headingText: <span class="hljs-built_in">string</span>;
  urlFragment: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">interface</span> IIsClosedOpts {
  urlFragment: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">class</span> MyPage <span class="hljs-keyword">extends</span> Page&lt;stores.PageNodeStore, IIsOpenOpts, IIsClosedOpts&gt; {

  <span class="hljs-keyword">get</span> heading() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._store.Element(
      xpath(<span class="hljs-string">'//h1'</span>)
    );
  }

  isOpen(opts: IIsOpenOpts) {
    <span class="hljs-keyword">return</span> browser.getUrl().indexOf(opts.urlFragment) &gt;= <span class="hljs-number">0</span> &amp;&amp;
      <span class="hljs-keyword">this</span>.heading.currently.hasText(opts.headingText);
  }

  isClosed(opts: IIsClosedOpts) {
    <span class="hljs-keyword">return</span> browser.getUrl().indexOf(opts.urlFragment) &lt; <span class="hljs-number">0</span> ||
      <span class="hljs-keyword">this</span>.heading.currently.not.hasAnyText();
  }
}

<span class="hljs-keyword">const</span> myPage = <span class="hljs-keyword">new</span> MyPage({
  store: stores.pageNode
});

myPage.wait.isOpen({
  headingText: <span class="hljs-string">'Login'</span>,
  urlFragment: <span class="hljs-string">'login'</span>,
  timeout: <span class="hljs-number">10000</span>
});
</code></pre>
<p>The types you defined for <code>IsOpenOpts</code> and <code>IsClosedOpts</code> will then be merged
with the default <code>Workflo.ITimeoutInterval</code> type, which consists of an <code>interval</code>
and a <code>timeout</code> property, and will be used to define the type of the arguments
object passed to the <code>wait.isOpen</code>, <code>wait.isClosed</code>, <code>eventually.isOpen</code> and
<code>eventually.isOpen</code> functions.</p>
<h3><a class="anchor" aria-hidden="true" id="instantiating-and-exporting-pages"></a><a href="#instantiating-and-exporting-pages" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Instantiating and Exporting Pages</h3>
<p>Since pages are stateless and basically serve as an interface to invoke
state interaction functions on the page nodes defined within its scope,
we usually do not need more than one instance of a certain <code>Page</code> class.</p>
<p>I typically create and export this single instance of a <code>Page</code> class at the bottom
of the page's file:</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> FeedPage <span class="hljs-keyword">extends</span> BasePage&lt;stores.pageNode&gt; {
  <span class="hljs-comment">/*...*/</span>
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> feed = <span class="hljs-keyword">new</span> FeedPage();
</code></pre>
<p>In addition, you also need to add an <code>export *</code> entry for each page file to the <code>index.ts</code> file
located in the <code>src/page_objects/pages</code> folder:</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">'./FeedPage'</span>;
<span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">'./RegistrationPage'</span>;
</code></pre>
<p>When writing testcases are implementing steps, all of your page classes and instances
will now be available on the <code>pages</code> object which you can import from the <code>?/page_objects</code> folder:</p>
<p><img src="/wdio-workflo/docs/assets/importing_pages.png" alt="page classes and instances are available via the `page` object"></p>
<h2><a class="anchor" aria-hidden="true" id="base-page-class"></a><a href="#base-page-class" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Base Page Class</h2>
<p>In most cases, the different pages of a tested web application will all share some
common structure or behavior. For this reason, it is advisable to create a
<code>BasePage</code> class that implements common behavior of all page classes derived
from the base page class.</p>
<p>The <code>BasePage</code> class of the wdio-workflo-example repository acts as the
<a href="#code-example">main code example</a> of this guide.</p>
<p>It provides common functionalities and elements of each page of wdio-workflo's
demo website:</p>
<ul>
<li>It implements <code>isOpen</code> and <code>isClosed</code> because all pages share the same page loading behavior</li>
<li>It defines a <code>container</code> and a <code>heading</code> page node for each page</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="page-fragments"></a><a href="#page-fragments" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Page Fragments</h2>
<p>For big and complex pages, it can sometimes be useful to split a page into so-called
page fragments. This helps you to better organize your pages and avoid clutter.</p>
<p>Page fragments also inherit from wdio-workflo's <code>Page</code> class and they map
the structure of certain areas of a website, for example a footer, a header or
a toolbar.</p>
<p>You can then simply instantiate your page fragments as properties of your
complex, combined page class:</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">import</span> { stores } <span class="hljs-keyword">from</span> <span class="hljs-string">'?/page_objects'</span>;
<span class="hljs-keyword">import</span> { Page, IPageOpts } <span class="hljs-keyword">from</span> <span class="hljs-string">'./Page'</span>;

<span class="hljs-keyword">class</span> Toolbar <span class="hljs-keyword">extends</span> Page&lt;stores.PageNodeStore&gt; {

  <span class="hljs-keyword">get</span> container() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._store.Element(
      xpath(<span class="hljs-string">'//div'</span>).classContains(<span class="hljs-string">'toolbar'</span>)
    )
  }

  <span class="hljs-keyword">get</span> copyButton() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.container.$.Element(
      xpath(<span class="hljs-string">'//button'</span>).text(<span class="hljs-string">'Copy'</span>)
    )
  }

  isOpen() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.container.currently.exists();
  }

  isClosed() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.container.currently.not.exists();
  }
}
</code></pre>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">import</span> { stores } <span class="hljs-keyword">from</span> <span class="hljs-string">'?/page_objects'</span>;
<span class="hljs-keyword">import</span> { Page, IPageOpts } <span class="hljs-keyword">from</span> <span class="hljs-string">'./Page'</span>;

<span class="hljs-keyword">import</span> { Header } <span class="hljs-keyword">from</span> <span class="hljs-string">'./'</span>;
<span class="hljs-keyword">import</span> { Footer } <span class="hljs-keyword">from</span> <span class="hljs-string">'./'</span>;
<span class="hljs-keyword">import</span> { Toolbar } <span class="hljs-keyword">from</span> <span class="hljs-string">'./'</span>;

<span class="hljs-keyword">class</span> EditorPage <span class="hljs-keyword">extends</span> Page&lt;stores.PageNodeStore&gt; {

  readonly header = <span class="hljs-keyword">new</span> Header({store: stores.pageNode})
  readonly footer = <span class="hljs-keyword">new</span> Footer({store: stores.pageNode})
  readonly toolbar = <span class="hljs-keyword">new</span> Toolbar({store: stores.pageNode})
}

<span class="hljs-keyword">const</span> editor = <span class="hljs-keyword">new</span> EditorPage();

<span class="hljs-comment">/*...*/</span>

editor.toolbar.copyButton.click();
</code></pre>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/wdio-workflo/docs/store"><span class="arrow-prev">← </span><span>Store</span></a><a class="docs-next button" href="/wdio-workflo/docs/steps"><span>Steps</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#overview-and-objective">Overview and Objective</a></li><li><a href="#location-and-naming-convention">Location and Naming Convention</a></li><li><a href="#code-example">Code Example</a></li><li><a href="#structure">Structure</a><ul class="toc-headings"><li><a href="#typing-and-constructor">Typing and Constructor</a></li><li><a href="#defining-page-nodes">Defining Page Nodes</a></li><li><a href="#implementing-lifecycle-methods">Implementing &quot;LifeCycle&quot; Methods</a></li><li><a href="#instantiating-and-exporting-pages">Instantiating and Exporting Pages</a></li></ul></li><li><a href="#base-page-class">Base Page Class</a></li><li><a href="#page-fragments">Page Fragments</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/wdio-workflo/" class="nav-home"><img src="/wdio-workflo/img/logo.svg" alt="Wdio-Workflo" width="66" height="58"/></a><div><h5>Docs</h5><a href="/wdio-workflo/docs/setup">Guides</a><a href="https://github.com/flohil/wdio-workflo-example">Examples</a><a href="/wdio-workflo/apiDoc">API Reference</a></div><div></div><div><h5>More</h5><a href="https://github.com/flohil/wdio-workflo">GitHub</a><a class="github-button" href="https://github.com/flohil/wdio-workflo" data-icon="octicon-star" data-count-href="/facebook/docusaurus/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><section class="copyright">Copyright © 2019 Florian Hilbinger</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '06ded81a116783d66e7d32d28ee42d05',
                indexName: 'wdio-workflo',
                inputSelector: '#search_input_react'
              });
            </script></body></html>