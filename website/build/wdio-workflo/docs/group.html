<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Group · Wdio-Workflo</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;h2&gt;&lt;a class=&quot;anchor&quot; aria-hidden=&quot;true&quot; id=&quot;overview-and-objective&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#overview-and-objective&quot; aria-hidden=&quot;true&quot; class=&quot;hash-link&quot;&gt;&lt;svg class=&quot;hash-link-icon&quot; aria-hidden=&quot;true&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Overview and Objective&lt;/h2&gt;
"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Group · Wdio-Workflo"/><meta property="og:type" content="website"/><meta property="og:url" content="https://flohil.github.io/wdio-workflo/index.html"/><meta property="og:description" content="&lt;h2&gt;&lt;a class=&quot;anchor&quot; aria-hidden=&quot;true&quot; id=&quot;overview-and-objective&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#overview-and-objective&quot; aria-hidden=&quot;true&quot; class=&quot;hash-link&quot;&gt;&lt;svg class=&quot;hash-link-icon&quot; aria-hidden=&quot;true&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Overview and Objective&lt;/h2&gt;
"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/wdio-workflo/img/favicon.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/rainbow.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><link rel="stylesheet" href="/wdio-workflo/css/main.css"/><script src="/wdio-workflo/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/wdio-workflo/"><img class="logo" src="/wdio-workflo/img/logo.svg" alt="Wdio-Workflo"/><h2 class="headerTitleWithLogo">Wdio-Workflo</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/wdio-workflo/docs/setup" target="_self">Guides</a></li><li class=""><a href="/wdio-workflo/demo" target="_self">Demo Page</a></li><li class=""><a href="https://github.com/flohil/wdio-workflo-example" target="_self">Examples</a></li><li class=""><a href="/wdio-workflo/apiDoc" target="_self">API</a></li><li class=""><a href="https://github.com/flohil/wdio-workflo" target="_self">Github</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Page Objects</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Getting Started</h3><ul class=""><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/setup">Setup</a></li><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/firstTest">Writing your first Test</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Configuration</h3><ul class=""><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/config">Configuration Options</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Architecture</h3><ul class=""><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/classes">Class Diagram</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Specs</h3><ul class=""><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/specs">Specs</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Page Objects</h3><ul class=""><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/pageObjects">Page Objects</a></li><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/element">Element</a></li><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/list">List</a></li><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/map">Map</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/wdio-workflo/docs/group">Group</a></li><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/store">Store</a></li><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/page">Page</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Steps</h3><ul class=""><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/steps">Steps</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Testcases</h3><ul class=""><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/testcases">Testcases</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Customizing Page Nodes</h3><ul class=""><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/customPageNodes">Introduction</a></li><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/customElement">Customizing an Element</a></li><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/customList">Customizing a List</a></li><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/customMap">Customizing a Map</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Various Tools</h3><ul class=""><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/xpathBuilder">XPath Builder</a></li><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/getUid">The `getUid` Function</a></li><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/executionLists">Execution Lists</a></li><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/manualResults">Manual Results</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Testrunner</h3><ul class=""><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/cliOptions">CLI Options</a></li><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/runningTests">Running Tests</a></li><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/debugging">Debugging</a></li><li class="navListItem"><a class="navItem" href="/wdio-workflo/docs/reporters">Reporters</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">Group</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" id="overview-and-objective"></a><a href="#overview-and-objective" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Overview and Objective</h2>
<p>Wdio-workflo's <code>PageElementGroup</code> manages an arbitrary structure of <code>PageNode</code>
instances of various classes. These classes can be (derivations of) <code>PageElement</code>,
<code>PageElementList</code>, <code>PageElementMap</code> or even another, nested <code>PageElementGroup</code>.</p>
<p>A typical website component that should be mapped by a <code>PageElementGroup</code> is
a form, since forms usually consist of HTML elements of various types, like
text input fields, dropdowns, checkboxes, radio buttons, labels and textareas.</p>
<p>Unlike other page node classes, a <code>PageElementGroup</code> has no XPath selector
of its own. It merely provides a way to define a structure of page nodes
and to execute the same function on each of these page nodes. In this regard,
a <code>PageElementGroup</code> works similar to the
<a href="https://en.wikipedia.org/wiki/Composite_pattern">composite pattern</a>:</p>
<p><em>&quot;In software engineering, the composite pattern is a partitioning design pattern. The composite pattern describes a group of objects that is treated the same way as a single instance of the same type of object. The intent of a composite is to &quot;compose&quot; objects into tree structures to represent part-whole hierarchies. Implementing the composite pattern lets clients treat individual objects and compositions uniformly.&quot;</em> - Quote from wikipedia.org</p>
<p>As noted in the above quote, a <code>PageElementGroup</code> manages a tree-like structure
of page nodes. The leaf page nodes are always <code>PageElement</code> instances that either
reside directly within the group's content, or are managed by one of the
lists, maps or nested groups located in the group's content.</p>
<p>The main advantage of using a <code>PageElementGroup</code> to represent an HTML form
is that if you want to fill in the form, you don't need to invoke the <code>setValue()</code>
function for each form element, but instead, you simply pass the values of all
form elements to the <code>setValue()</code> function of the <code>PageElementGroup</code>. The group
then internally invokes the <code>setValue()</code> function for all form elements and
passes the value for each form element to the corresponding function invocation.
A code example showing you how to use the <code>setValue()</code> function of a group can be
found in the <a href=""><code>ValuePageElementGroup</code> section</a> of this guide.</p>
<p>Finally, like the other <code>PageNode</code> classes, <code>PageElementGroup</code> also features a
<code>currently</code> and an <code>eventually</code> API to check if some, none or all of the group's
page nodes currently/eventually have a certain state, and a <code>wait</code> API
to wait for some, none or all of the group's page nodes to reach a certain state.</p>
<h2><a class="anchor" aria-hidden="true" id="creating-a-pageelementgroup"></a><a href="#creating-a-pageelementgroup" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Creating a <code>PageElementGroup</code></h2>
<h3><a class="anchor" aria-hidden="true" id="elementgroup-factory-method"></a><a href="#elementgroup-factory-method" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>ElementGroup()</code> Factory Method</h3>
<p>Instead of manually invoking the constructor of <code>PageElementGroup</code> using the <code>new</code> keyword,
you should always call the <code>ElementGroup()</code> factory method of the <a href="/wdio-workflo/docs/store">PageNodeStore</a>
class to create an instance of the <code>PageElementGroup</code> class:</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">import</span> { stores } <span class="hljs-keyword">from</span> <span class="hljs-string">'?/page_objects'</span>;

<span class="hljs-keyword">const</span> group = stores.pageNode.ElementGroup({
  <span class="hljs-keyword">get</span> link() {
    <span class="hljs-keyword">return</span> stores.pageNode.Link(<span class="hljs-string">'//a'</span>);
  },
  <span class="hljs-keyword">get</span> label() {
    <span class="hljs-keyword">return</span> stores.pageNode.Element(
      xpath(<span class="hljs-string">'//span'</span>).classContains(<span class="hljs-string">'label'</span>)
    );
  }
});
</code></pre>
<p>As you can see from the example above, the <code>ElementGroup()</code> factory method, unlike
the factory methods of other <code>PageNode</code> classes, does not take an XPath selector,
but an object containing the content of the group (all page nodes managed by the group).</p>
<h3><a class="anchor" aria-hidden="true" id="type-parameters"></a><a href="#type-parameters" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Type Parameters</h3>
<p>The <code>PageElementMap</code> class has two type parameters:</p>
<ul>
<li>The type of the <code>PageNodeStore</code> associated with the group to create other page nodes.</li>
<li>The type of the group's content (all page nodes managed by the group).</li>
</ul>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> PageElementGroup&lt;
  Store <span class="hljs-keyword">extends</span> PageNodeStore,
  Content <span class="hljs-keyword">extends</span> {[K <span class="hljs-keyword">in</span> keyof Content] : Workflo.PageNode.IPageNode}
&gt; <span class="hljs-keyword">extends</span> PageNode&lt;Store&gt;
</code></pre>
<p>Please not that the <code>Content</code> type parameter of <code>PageElementGroup</code> requires forces
each property of the group's content object to implement the <code>Workflo.PageNode.IPageNode</code>
interface - or in other words, to be a <code>PageNode</code>.</p>
<h3><a class="anchor" aria-hidden="true" id="constructor"></a><a href="#constructor" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Constructor</h3>
<p>The constructor of <code>PageElementMap</code> requires two parameters:</p>
<ul>
<li>The <code>id</code> of the group which uniquely identifies the group. Simply put, to create
this <code>id</code>, <code>PageNodeStore</code> transforms the content of a group into one giant string.</li>
<li>The <code>opts</code> parameter containing properties to configure the <code>PageElementGroup</code>.</li>
</ul>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">constructor</span>(<span class="hljs-params">id: <span class="hljs-built_in">string</span>, opts: IPageElementGroupOpts&lt;Store, Content&gt;</span>) {
  <span class="hljs-comment">/*...*/</span>
}
</code></pre>
<p>The properties of the <code>opts</code> parameter are:</p>
<ul>
<li><code>store</code> =&gt; The <code>PageNodeStore</code> instance associated with the <code>PageElementGroup</code>.</li>
<li><code>content</code> =&gt; An object containing all <code>PageNode</code> instances managed by the group.</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="content-object"></a><a href="#content-object" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>content</code> Object</h3>
<p>The <code>content</code> object of a <code>PageElementGroup</code> can be used to create an arbitrary
structure of classes derived from <code>PageNode</code> - these can by (derivations of)
<code>PageElement</code>, <code>PageElementList</code>, <code>PageElementMap</code> and even nested <code>PageElementGroup</code> classes. The keys of the <code>content</code> object are the names used to access the group's
page nodes, and the values are the page node instances themselves.</p>
<p>In this regard, the <code>content</code> object is very similar to the <code>Page</code> class, which
also manages page nodes of any classes. And like page nodes of the <code>Page</code> class,
all page nodes of the <code>content</code> object need to be defined using JavaScript getters.
To find out why, please read the <a href="/wdio-workflo/docs/page#defining-page-nodes-using-javascript-getters">Defining Page Nodes using JavaScript Getters</a> section of the <code>Page</code> guide.</p>
<p>Below you can see an example of a <code>PageElementGroup</code> content object:</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">import</span> { stores } <span class="hljs-keyword">from</span> <span class="hljs-string">'?/page_objects'</span>;

<span class="hljs-keyword">const</span> container = stores.pageNode.Element(
  xpath(<span class="hljs-string">'//div'</span>).id(<span class="hljs-string">'groupContainer'</span>)
);

<span class="hljs-keyword">const</span> group = stores.pageNode.ElementGroup({
  <span class="hljs-keyword">get</span> label() {
    <span class="hljs-comment">// The `label` page element has the following XPath:</span>
    <span class="hljs-comment">// '//div[@id="groupContainer"]//span[contains(@class, "label")]'</span>
    <span class="hljs-keyword">return</span> container.$.Element(
      xpath(<span class="hljs-string">'//span'</span>).classContains(<span class="hljs-string">'label'</span>)
    );
  },
  <span class="hljs-keyword">get</span> titlesList() {
    <span class="hljs-keyword">return</span> container.$.ElementList(
      xpath(<span class="hljs-string">'//h3'</span>)
    );
  },
  <span class="hljs-keyword">get</span> navigationMap() {
    <span class="hljs-keyword">return</span> container.$.LinkMap(
      xpath(<span class="hljs-string">'//a'</span>).classContains(<span class="hljs-string">'navigation'</span>), {
        identifier: {
          mappingObject: {
            demo: <span class="hljs-string">'Demo Page'</span>,
            examples: <span class="hljs-string">'Examples'</span>,
            api: <span class="hljs-string">'API'</span>
          },
          mappingFunc: <span class="hljs-function">(<span class="hljs-params">baseSelector, value</span>) =&gt;</span> xpath(baseSelector).text(value)
        }
      }
    );
  },
  <span class="hljs-keyword">get</span> nestedGroup() {
    <span class="hljs-keyword">return</span> container.$.ElementGroup({
      <span class="hljs-keyword">get</span> errorMessageArea() {
        <span class="hljs-keyword">return</span> container.$.Element(
          xpath(<span class="hljs-string">'//div'</span>).id(<span class="hljs-string">'errors'</span>)
        );
      },
      <span class="hljs-keyword">get</span> successMessageArea() {
        <span class="hljs-keyword">return</span> container.$.Element(
          xpath(<span class="hljs-string">'//div'</span>).id(<span class="hljs-string">'successes'</span>)
        );
      }
    });
  }
});
</code></pre>
<p>Although a <code>PageElementGroup</code> has no XPath selector of its own, in a lot of cases
the page nodes of a group all reside within a common HTML container element. Like in
the example above, you can create such a container as a <code>PageElement</code> and then use
its <code>$</code> accessor to instantiate the page nodes defined within the <code>content</code> object of a group. By doing so, the XPath selector of the container will be prepended to the XPath
selectors of the group's page nodes.</p>
<h2><a class="anchor" aria-hidden="true" id="accessing-group-elements"></a><a href="#accessing-group-elements" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Accessing Group Elements</h2>
<p>To access the <code>PageNode</code> instances managed by a group from outside of the
<code>PageElementGroup</code> class, we need to use the group's <code>$</code> accessor which returns
the <code>content</code> object of the group:</p>
<p><img src="/wdio-workflo/docs/assets/group_dollar_accessor.png" alt="The `$` accessor of `PageElementGroup`"></p>
<p>So if we wanted to click the <code>label</code> element of our <code>group</code> from the above
code example, we would write:</p>
<pre><code class="hljs css language-typescript">group.$.label.click();
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="state-functions"></a><a href="#state-functions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>State Functions</h2>
<h3><a class="anchor" aria-hidden="true" id="pageelementgroup-example-code"></a><a href="#pageelementgroup-example-code" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>PageElementGroup</code> Example Code</h3>
<p>The following sections of the &quot;State Functions&quot; chapter refer to the below
example code of a <code>PageElementGroup</code> definition to avoid code duplication:</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">import</span> { stores } <span class="hljs-keyword">from</span> <span class="hljs-string">'?/page_objects'</span>;

<span class="hljs-keyword">const</span> container = stores.pageNode.Element(
  xpath(<span class="hljs-string">'//div'</span>).id(<span class="hljs-string">'groupContainer'</span>)
);

<span class="hljs-keyword">const</span> group = stores.pageNode.ElementGroup({
  <span class="hljs-keyword">get</span> element() {
    <span class="hljs-keyword">return</span> container.$.Element(<span class="hljs-string">'//span'</span>);
  },
  <span class="hljs-keyword">get</span> list() {
    <span class="hljs-keyword">return</span> container.$.ElementList(<span class="hljs-string">'//h3'</span>);
  },
  <span class="hljs-keyword">get</span> map() {
    <span class="hljs-keyword">return</span> container.$.ElementMap(<span class="hljs-string">'//a'</span>, {
      identifier: {
        mappingObject: {
          demo: <span class="hljs-string">'Demo Page'</span>,
          examples: <span class="hljs-string">'Examples'</span>,
        },
        mappingFunc: <span class="hljs-function">(<span class="hljs-params">baseSelector, value</span>) =&gt;</span> xpath(baseSelector).text(value)
      }
    });
  },
  <span class="hljs-keyword">get</span> nestedGroup() {
    <span class="hljs-keyword">return</span> container.$.ElementGroup({
      <span class="hljs-keyword">get</span> nestedElement() {
        <span class="hljs-keyword">return</span> container.$.Element(xpath(<span class="hljs-string">'//div'</span>));
      },
    });
  }
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="composite-pattern"></a><a href="#composite-pattern" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Composite Pattern</h3>
<p>As already mentioned, the content of a <code>PageElementGroup</code> defines an arbitrary
tree structure of <code>PageNode</code> instances. Each <code>PageNode</code> instance can be
a <code>PageElement</code>, <code>PageElementList</code>, <code>PageElementMap</code> or a nested <code>PageElementGroup</code>.
The leaf nodes of this tree structure are always <code>PageElement</code> instances.</p>
<p>The <code>PageElementGroup</code> allows us to invoke state retrieval, state check and
action functions on each <code>PageNode</code> instance managed by the group with one simple
call of a function defined on the group itself.</p>
<p>Together, these two features of a <code>PageElementGroup</code> represent an implementation
of the <a href="https://en.wikipedia.org/wiki/Composite_pattern">composite pattern</a>,
which allows us to treat a group of <code>PageNode</code> instances the same way as a single
<code>PageNode</code> instance.</p>
<p>When you invoke a state retrieval, state check or action function on the
<code>PageElementGroup</code> class, the group iterates over all of its managed <code>PageNode</code>
instances and invokes the respective function on each <code>PageNode</code> of the group:</p>
<ul>
<li>If this <code>PageNode</code> is a <code>PageElement</code>, the group has reached a leaf node.</li>
<li>If this <code>PageNode</code> is a <code>PageElementList</code> or <code>PageElementMap</code>, the group further
invokes the respective function on the <code>PageElement</code> instances managed by the list
or map.</li>
<li>If the <code>PageNode</code> is a nested <code>PageElementGroup</code>, it invokes the respective
function on each of its managed <code>PageNode</code> instances.</li>
</ul>
<p>This process of function invocations continues recursively until the function was
invoked on each <code>PageElement</code> leaf node of the outermost group.</p>
<p>You can skip the invocation of the function for certain <code>PageNode</code> instances
by using a filter mask. The <a href="#filter-masks">Filter Masks section</a> of this guide
shows you how to do that.</p>
<h3><a class="anchor" aria-hidden="true" id="state-retrieval-functions"></a><a href="#state-retrieval-functions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>State Retrieval Functions</h3>
<p>State retrieval functions of the <code>PageElementGroup</code> class fulfil the same purpose
as those of the <code>PageElement</code> class: For each <code>PageElement</code> leaf node managed by the
group, they retrieve the value of a certain attribute of the HTML element that is
wrapped by <code>PageElement</code> from the website. They return an object whose keys are
taken from the group's content object and whose values represent the values
of the retrieved HTML attribute for each <code>PageNode</code> managed by the group:</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">const</span> groupTexts = group.getText();

<span class="hljs-comment">// Assuming the group's `list` page node manages two page elements,</span>
<span class="hljs-comment">// the content of the `groupTexts` variable could be:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// {</span>
<span class="hljs-comment">//   element: 'Text of Element',</span>
<span class="hljs-comment">//   list: ['Text of first List Element', 'Text of second List Element'],</span>
<span class="hljs-comment">//   map: {</span>
<span class="hljs-comment">//     demo: 'Demo Page',</span>
<span class="hljs-comment">//     examples: 'Examples'</span>
<span class="hljs-comment">//   },</span>
<span class="hljs-comment">//   nestedGroup: {</span>
<span class="hljs-comment">//     nestedElement: 'Text of Nested Element'</span>
<span class="hljs-comment">//   }</span>
<span class="hljs-comment">// };</span>
</code></pre>
<p>You can use a <a href="#filter-masks">filter mask</a> to skip the invocation of a state
retrieval function for certain <code>PageElement</code> leaf nodes:</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">const</span> filteredGroupTexts = group.getText({
  element: <span class="hljs-literal">true</span>,
  map: {
    examples: <span class="hljs-literal">true</span>
  }
});

<span class="hljs-comment">// The content of the `filteredGroupTexts` variable would now be:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// {</span>
<span class="hljs-comment">//   element: 'Text of Element',</span>
<span class="hljs-comment">//   list: undefined,</span>
<span class="hljs-comment">//   map: {</span>
<span class="hljs-comment">//     demo: undefined,</span>
<span class="hljs-comment">//     examples: 'Examples'</span>
<span class="hljs-comment">//   },</span>
<span class="hljs-comment">//   nestedGroup: undefined</span>
<span class="hljs-comment">// };</span>
</code></pre>
<p>For more information about the types of available state retrieval functions,
please read the <a href="/wdio-workflo/docs/element#state-retrieval-functions">State Retrieval Functions section</a>
of the <code>PageElement</code> guide. Please note that not all types of <code>PageElement</code> state
retrieval functions are also available on a <code>PageElementGroup</code>.</p>
<h3><a class="anchor" aria-hidden="true" id="action-functions"></a><a href="#action-functions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Action Functions</h3>
<p>Action functions change the state of the tested web application by interacting
with HTML elements that are mapped by <code>PageElement</code> instances. To execute an
action function on each <code>PageElement</code> leaf node of a <code>PageElementGroup</code>, you have
two options:</p>
<ul>
<li>You can access each <code>PageNode</code> instance of the group and its nested groups
via the <code>$</code> accessor and invoke an action function on each.</li>
<li>You can use the <code>eachDo()</code> method of the <code>PageElementGroup</code> which automatically
loops over the managed <code>PageNode</code> instances and invokes an action function which
you need to pass to <code>eachDo()</code> on each page node. Using <code>eachDo()</code> allows you to
optionally pass a <a href="#filter-masks">filter mask</a> as second parameter to skip the action
function's invocation for certain <code>PageElement</code> leaf nodes.</li>
</ul>
<p>The following code example compares both options for executing action functions
on each page node of a <code>PageElementGroup</code>:</p>
<pre><code class="hljs css language-typescript"><span class="hljs-comment">// Click on each page element leaf node of the group after accessing the group's</span>
<span class="hljs-comment">// page nodes via the '$' accessor.</span>
group.$.element.click();
group.$.list.click();
group.$.map.click();
group.$.nestedGroup.$.nestedElement.click();

<span class="hljs-comment">// Clicks on the `element` page element, each page element managed by the `list`</span>
<span class="hljs-comment">// page node and the `demo` page element of the `map` page node. For all other</span>
<span class="hljs-comment">// page element leaf nodes of the group, the invocation of the `click()` function</span>
<span class="hljs-comment">// will be skipped because they are not included in the filter mask.</span>
group.eachDo(
  <span class="hljs-function"><span class="hljs-params">pageNode</span> =&gt;</span> pageNode.click(),
  {
    element: <span class="hljs-literal">true</span>,
    list: <span class="hljs-literal">true</span>,
    map: {
      demo: <span class="hljs-literal">true</span>
    }
  }
);
</code></pre>
<p>For more information about the types of available action functions,
please read the <a href="/wdio-workflo/docs/element#action-functions">Action Functions section</a> of the <code>PageElement</code> guide.</p>
<h3><a class="anchor" aria-hidden="true" id="state-check-functions"></a><a href="#state-check-functions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>State Check Functions</h3>
<p>The state check functions of the <code>PageElementGroup</code> class let you check if all
or some of the group's <code>PageElement</code> leaf nodes currently or eventually have an
expected state. They also allow you to wait for some or all page element leaf
nodes of a group to reach an expected state within a specific timeout.</p>
<p>If a state check function of <code>PageElementGroup</code> requires you to pass the expected
attribute states as a parameter, this parameter needs to be an object whose
keys are taken from the group's content object and whose values represent the values
of the checked HTML attribute for each <code>PageNode</code> instance. If you omit a property
representing a certain managed <code>PageNode</code> instance in the parameter object,
the invocation of the state check function will be skipped for this page node
(and all of its page element leaf nodes of the page node is a list, map or group).</p>
<p>For state check functions that do not require you to pass the expected attribute
states as a parameter, you can use a <a href="#filter-masks">filter mask</a> to skip the
invocation of the state check function for certain <code>PageElement</code> leaf nodes.</p>
<p>The following code example demonstrates the usage of the state check functions
of a <code>PageElementGroup</code>:</p>
<pre><code class="hljs css language-typescript">
<span class="hljs-comment">// Checks if the texts of all page element leaf nodes currently match the</span>
<span class="hljs-comment">// expected values.</span>
group.currently.hasText({
  element: <span class="hljs-string">'Text of Element'</span>,
  list: [<span class="hljs-string">'Text of first List Element'</span>, <span class="hljs-string">'Text of second List Element'</span>],
  map: {
    demo: <span class="hljs-string">'Demo Page'</span>,
    examples: <span class="hljs-string">'Examples'</span>
  },
  nestedGroup: {
    nestedElement: <span class="hljs-string">'Text of Nested Element'</span>
  }
});

<span class="hljs-comment">// Checks if the `element` page element and the `nestedElement` page element of</span>
<span class="hljs-comment">// `nestedGroup` currently have any text (are not empty).</span>
linkMap.currently.hasAnyText({
  element: <span class="hljs-literal">true</span>,
  nestedGroup: {
    nestedElement: <span class="hljs-literal">true</span>
  }
});

<span class="hljs-comment">// Waits for all page element leaf nodes of the group to become visible.</span>
<span class="hljs-comment">// If one or more page element leaf nodes do not become visible within the default</span>
<span class="hljs-comment">// timeout defined for each managed page element, list or map, an error will</span>
<span class="hljs-comment">// be thrown.</span>
group.wait.isVisible();

<span class="hljs-comment">// Waits until the `element` page element and the `nestedElement` page element of</span>
<span class="hljs-comment">// `nestedGroup` are no longer visible. Both of these page element are allowed</span>
<span class="hljs-comment">// to take up to 3 seconds each to become no longer visible. If they fail to do</span>
<span class="hljs-comment">// so, an error will be thrown.</span>
linkMap.wait.not.isVisible({ timeout: <span class="hljs-number">3000</span>, filterMask: {
  element: <span class="hljs-literal">true</span>,
  nestedGroup: {
    nestedElement: <span class="hljs-literal">true</span>
  }
}});

<span class="hljs-comment">// Checks if the text of `element` eventually contains 'of Element', if the text</span>
<span class="hljs-comment">// of the second page element managed by `list` eventually contains</span>
<span class="hljs-comment">// 'second List Element' and if the text of the `nestedElement` page element of</span>
<span class="hljs-comment">// `nestedGroup` contains 'of Nested'.</span>
group.eventually.containsText({
  element: <span class="hljs-string">'of Element'</span>,
  list: [<span class="hljs-literal">undefined</span>, <span class="hljs-string">'second List Element'</span>],
  nestedGroup: {
    nestedElement: <span class="hljs-string">'of Nested'</span>
  }
});
</code></pre>
<p>To find out how state check functions behave differently when invoked on the
<code>currently</code>, <code>wait</code> or <code>eventually</code> API of a <code>PageElementGroup</code>, please read the
corresponding sections of this guide:
<a href="#the-currently-api">The <code>currently</code> API</a>,
<a href="#the-wait-api">The <code>wait</code> API</a>,
<a href="#the-eventually-api">The <code>eventually</code> API</a>.</p>
<p>For more information about the types of available state check functions,
please read the <a href="/wdio-workflo/docs/element#state-check-functions">State Check Functions section</a>
of the <code>PageElement</code> guide. Please note that not all types of <code>PageElement</code> state
check functions are also available on a <code>PageElementGroup</code>.</p>
<h3><a class="anchor" aria-hidden="true" id="filter-masks"></a><a href="#filter-masks" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Filter Masks</h3>
<p>The <code>PageElementGroup</code> filter mask allows you to restrict the execution of a
state retrieval, action or state check function to certain <code>PageNode</code> instances
managed by the group.</p>
<p>The <code>PageElementGroup</code> filter mask is an object whose keys are taken from the group's
content object and whose values are determined by the filter masks of the
respective <code>PageNode</code> instances:</p>
<ul>
<li>For <code>PageElement</code> instances, you can set the value of a filter mask property
to <code>true</code> if you want a function to be executed for the respective page element,
and <code>false</code> if you want to skip the function invocation.</li>
<li>The filter mask formats of lists and maps are explained in full detail in the
filter mask sections of the <a href="list#filter-masks">PageElementList</a> and <a href="map#filter-masks">PageElementMap</a> guides.</li>
<li>If you don't define a property for a specific <code>PageNode</code> in the filter mask object, the function call for the respective page node will be skipped.</li>
</ul>
<p>The filter mask can be set via the last parameter of a state retrieval, action or
state check function. If such a function has other optional parameters, the filter
mask can be defined via the <code>filterMask</code> property of the <code>opts</code> parameter (which
is always the last function parameter). Otherwise, the filter mask itself represents
the last function parameter.</p>
<p>Here are some examples for how to use filter masks with a <code>PageElementGroup</code>:</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">import</span> { stores } <span class="hljs-keyword">from</span> <span class="hljs-string">'?/page_objects'</span>;

<span class="hljs-keyword">const</span> container = stores.pageNode.Element(
  xpath(<span class="hljs-string">'//div'</span>).id(<span class="hljs-string">'groupContainer'</span>)
);

<span class="hljs-keyword">const</span> group = stores.pageNode.ElementGroup({
  <span class="hljs-keyword">get</span> element() {
    <span class="hljs-keyword">return</span> container.$.Element(<span class="hljs-string">'//span'</span>);
  },
  <span class="hljs-keyword">get</span> list() {
    <span class="hljs-keyword">return</span> container.$.ElementList(<span class="hljs-string">'//h3'</span>);
  },
  <span class="hljs-keyword">get</span> map() {
    <span class="hljs-keyword">return</span> container.$.ElementMap(<span class="hljs-string">'//a'</span>, {
      identifier: {
        mappingObject: {
          demo: <span class="hljs-string">'Demo Page'</span>,
          examples: <span class="hljs-string">'Examples'</span>,
        },
        mappingFunc: <span class="hljs-function">(<span class="hljs-params">baseSelector, value</span>) =&gt;</span> xpath(baseSelector).text(value)
      }
    });
  },
  <span class="hljs-keyword">get</span> nestedGroup() {
    <span class="hljs-keyword">return</span> container.$.ElementGroup({
      <span class="hljs-keyword">get</span> nestedElement() {
        <span class="hljs-keyword">return</span> container.$.Element(xpath(<span class="hljs-string">'//div'</span>));
      },
    });
  }
});

<span class="hljs-comment">// The `getText()` function will be invoked for the `element` page element,</span>
<span class="hljs-comment">// all page elements of `list`, the `demo` page element of `map` and the</span>
<span class="hljs-comment">// `nestedElement` page element of `nestedGroup`.</span>
<span class="hljs-comment">// The `getText()` invocation will be skipped for the `examples` page element</span>
<span class="hljs-comment">// of `map` because its filter mask value is set to `false`.</span>
<span class="hljs-keyword">const</span> texts = group.getText({
  element: <span class="hljs-literal">true</span>,
  list: <span class="hljs-literal">true</span>,
  map: {
    demo: <span class="hljs-literal">true</span>,
    examples: <span class="hljs-literal">false</span>
  },
  nestedGroup: {
    nestedElement: <span class="hljs-literal">true</span>
  }
})

<span class="hljs-comment">// The `click()` function will only be invoked for the second page element</span>
<span class="hljs-comment">// of `list`. It will be skipped for the `element` page element because its</span>
<span class="hljs-comment">// filter mask value is `false`, for the first page element of `list` because</span>
<span class="hljs-comment">// its filter mask value is also `false`, and for all page elements managed by</span>
<span class="hljs-comment">// `map` and `nestedGroup` because the filter mask contains no property for them.</span>
group.eachDo(
  <span class="hljs-function"><span class="hljs-params">node</span> =&gt;</span> node.click(), {
  element: <span class="hljs-literal">false</span>,
  list: [<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>],
})

<span class="hljs-comment">// There are other optional parameters like `timeout`, therefore the filter mask</span>
<span class="hljs-comment">// is defined via the `filterMask` property of the `opts` parameter.</span>
<span class="hljs-comment">// The `hasAnyText` function will return `true` if the `element` and the `nestedElement`,</span>
<span class="hljs-comment">// both within 3 seconds each, have any text (are not empty).</span>
group.eventually.hasAnyText({ timeout: <span class="hljs-number">3000</span>, filterMask: {
  element: <span class="hljs-literal">true</span>,
  nestedGroup: {
    nestedElement: <span class="hljs-literal">true</span>
  }
}});
</code></pre>
<p>Filter masks are not available for state check functions that require you to pass
the expected attribute values as a parameter, e.g. <code>hasText(texts)</code> or
<code>containsValue(values)</code>. In these cases, you can skip the execution of the state
check function for a certain <code>PageNode</code> instance by simply not defining
an object property for the corresponding key:</p>
<pre><code class="hljs css language-typescript"><span class="hljs-comment">// The `hasDirectText` function will only be invoked for the `element` page element</span>
<span class="hljs-comment">// and the `examples` page element of `map`. It will return `true` if the direct text</span>
<span class="hljs-comment">// (the text that resides directly/one layer below the HTML element) of `element`</span>
<span class="hljs-comment">// is currently 'Element text' and the direct text of `map.examples` is currently</span>
<span class="hljs-comment">// 'Examples'.</span>
<span class="hljs-keyword">const</span> result = group.currently.hasDirectText({
  element: <span class="hljs-string">'Element text'</span>,
  map: {
    examples: <span class="hljs-string">'Examples'</span>
  }
});
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="waiting-mechanisms"></a><a href="#waiting-mechanisms" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Waiting Mechanisms</h2>
<h3><a class="anchor" aria-hidden="true" id="implicit-waiting"></a><a href="#implicit-waiting" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Implicit Waiting</h3>
<p><code>PageElementGroup</code> does not have an implicit waiting mechanism of its own.
However, if you invoke a state retrieval or action function on a <code>PageElement</code>
leaf node managed by a <code>PageElementGroup</code>, the
<a href="element#implicit-waiting">implicit waiting mechanism of the <code>PageElement</code></a> will be triggered.</p>
<h3><a class="anchor" aria-hidden="true" id="explicit-waiting-currently-wait-and-eventually"></a><a href="#explicit-waiting-currently-wait-and-eventually" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Explicit Waiting: <code>currently</code>, <code>wait</code> and <code>eventually</code></h3>
<p>The explicit waiting mechanisms of <code>PageElementGroup</code> are very similar to the
ones used by <code>PageElement</code> and you should read about them in the
<a href="/wdio-workflo/docs/element#explicit-waiting-currently-wait-and-eventually">Explicit Waiting</a>
section of the <a href="/wdio-workflo/docs/element"><code>PageElement</code> guide</a> before you continue reading
this guide.</p>
<p>To learn how the behavior of state retrieval and state check functions of the <code>PageElementGroup</code> class differs from its <code>PageElement</code> class equivalents, please
read the <a href="#state-function-types">State Function Types section of this guide</a>.</p>
<p>The types of available state retrieval and state check functions can be
found in the <a href="/wdio-workflo/docs/element#state-function-types">State Function Types section of the <code>PageElement</code> guide</a>. Please note that not all types of <code>PageElement</code>
state retrieval and state check functions are also available on a <code>PageElementGroup</code>.</p>
<h3><a class="anchor" aria-hidden="true" id="the-currently-api"></a><a href="#the-currently-api" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The <code>currently</code> API</h3>
<p>The <code>currently</code> API of the <code>PageElementGroup</code> class consists of state retrieval
functions and state check functions. It does not trigger an implicit wait on the
<code>PageNode</code> instances managed by the <code>PageElementGroup</code>.</p>
<p>The state retrieval functions of a group's <code>currently</code> API retrieve the values
of a certain HTML attribute for each <code>PageElement</code> leaf node managed by the group.
They return an object whose keys are taken from the group's content object and whose
values represent the current values of the retrieved HTML attribute for the respective
page nodes managed by the group.</p>
<p>The state check functions of the <code>currently</code> API check wether the <code>PageElement</code>
leaf nodes managed by the <code>PageElementGroup</code> currently have an expected state for a
certain HTML attribute.</p>
<p>By using a <a href="#filter-masks">filter mask</a>, you can skip the invocation of a
state retrieval or state check function for certain <code>PageElement</code> leaf nodes of
the group.</p>
<h3><a class="anchor" aria-hidden="true" id="the-wait-api"></a><a href="#the-wait-api" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The <code>wait</code> API</h3>
<h4><a class="anchor" aria-hidden="true" id="overview"></a><a href="#overview" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Overview</h4>
<p>The <code>wait</code> API of the <code>PageElementGroup</code> class allows you to explicitly wait
for some or all of the group's managed <code>PageElement</code> leaf nodes to have an expected
state. It consists of state check functions only which all return an instance
of the <code>PageElementGroup</code>.</p>
<p>If you use a <a href="#filter-masks">filter mask</a>, the <code>wait</code> API only waits for the group's
<code>PageElement</code> leaf nodes which are included by the filter mask to reach an expected
state. Otherwise, the <code>wait</code> API waits for all managed <code>PageElement</code> leaf nodes to reach
their expected state. If one or more <code>PageElement</code> leaf nodes fail to reach their
expected state within a specific timeout, an error will be thrown.</p>
<h4><a class="anchor" aria-hidden="true" id="timeout"></a><a href="#timeout" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Timeout</h4>
<p>The <code>timeout</code> within which the expected states of the <code>PageNode</code> instances must
be reached applies to each <code>PageElement</code> instance individually. So, if the <code>timeout</code>
was 3000 milliseconds, each <code>PageElement</code> instance managed by the group, or by
one of the group's <code>PageElementList</code> and <code>PageElementMap</code> page nodes, is allowed
to take up to 3 seconds to reach its expected state:</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">import</span> { stores } <span class="hljs-keyword">from</span> <span class="hljs-string">'?/page_objects'</span>;

<span class="hljs-keyword">const</span> container = stores.pageNode.Element(
  xpath(<span class="hljs-string">'//div'</span>).id(<span class="hljs-string">'groupContainer'</span>)
);

<span class="hljs-keyword">const</span> group = stores.pageNode.ElementGroup({
  <span class="hljs-keyword">get</span> element() {
    <span class="hljs-keyword">return</span> container.$.Element(<span class="hljs-string">'//span'</span>);
  },
  <span class="hljs-keyword">get</span> list() {
    <span class="hljs-keyword">return</span> container.$.ElementList(<span class="hljs-string">'//h3'</span>);
  },
  <span class="hljs-keyword">get</span> map() {
    <span class="hljs-keyword">return</span> container.$.ElementMap(<span class="hljs-string">'//a'</span>, {
      identifier: {
        mappingObject: {
          demo: <span class="hljs-string">'Demo Page'</span>,
          examples: <span class="hljs-string">'Examples'</span>,
        },
        mappingFunc: <span class="hljs-function">(<span class="hljs-params">baseSelector, value</span>) =&gt;</span> xpath(baseSelector).text(value)
      }
    });
  },
  <span class="hljs-keyword">get</span> nestedGroup() {
    <span class="hljs-keyword">return</span> container.$.ElementGroup({
      <span class="hljs-keyword">get</span> nestedElement() {
        <span class="hljs-keyword">return</span> container.$.Element(xpath(<span class="hljs-string">'//div'</span>));
      },
    });
  }
});

<span class="hljs-comment">// The `element` page element, all page elements managed by the `list` page node,</span>
<span class="hljs-comment">// all page elements managed by the `map` page node and all page elements</span>
<span class="hljs-comment">// managed by page nodes of `nestedGroup` are allowed to take up to 3 seconds each</span>
<span class="hljs-comment">// to become visible.</span>
linkMap.wait.isVisible({
  timeout: <span class="hljs-number">3000</span>
});
</code></pre>
<p>If we assume that the group's <code>list</code> page node in the above code examples manages
two page elements, there is a total of 6 page element leaf nodes:</p>
<ul>
<li>The <code>element</code> page element.</li>
<li>The two page elements managed by <code>list</code>.</li>
<li>The <code>demo</code> and <code>examples</code> page elements managed by <code>map</code>.</li>
<li>The <code>nestedElement</code> page element residing in the content of <code>nestedGroup</code>.</li>
</ul>
<p>Each of these 6 page elements can take up to 3 seconds to become visible.
So in total, the maximum possible wait time for this <code>isVisible()</code> invocation is
18 seconds. If one or more leaf page elements of <code>group</code> do not become visible
within 3 seconds, an error will be thrown.</p>
<p>For more information on how to configure the <code>timeout</code> and <code>interval</code> of
state check functions defined on the <code>wait</code> API of a page node class,
please read the <a href="/wdio-workflo/docs/element#the-wait-api"><code>wait</code> API section</a> of the <code>PageElement</code> guide.</p>
<h3><a class="anchor" aria-hidden="true" id="the-eventually-api"></a><a href="#the-eventually-api" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The <code>eventually</code> API</h3>
<h4><a class="anchor" aria-hidden="true" id="overview-1"></a><a href="#overview-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Overview</h4>
<p>The <code>eventually</code> API of the <code>PageElementGroup</code> class checks if some or all of
the <code>PageNode</code> instances managed by a <code>PageElementGroup</code> eventually reach an
expected state within a specific timeout. It consists of state check functions only
that return <code>true</code> if all <code>PageNode</code> instances for which the state check function
was executed eventually reached the expected state within the specified timeout.
Otherwise, <code>false</code> will be returned.</p>
<p>If you use a <a href="#filter-masks">filter mask</a>, the <code>eventually</code> API only checks the
state of <code>PageElement</code> leaf nodes which are included by the group's filter mask.
Otherwise, the <code>eventually</code> API checks the state of all managed <code>PageElement</code>
leaf nodes of the group.</p>
<h4><a class="anchor" aria-hidden="true" id="timeout-1"></a><a href="#timeout-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Timeout</h4>
<p>Like for the <code>wait</code> API, for the <code>eventually</code> API too the <code>timeout</code> within which
the expected states of the <code>PageElement</code> leaf nodes must be reached applies to
each <code>PageElement</code> leaf node individually.</p>
<p>For more information on how to configure the <code>timeout</code> and <code>interval</code> of
state check functions defined on the <code>eventually</code> API of a page node class,
please read the <a href="/wdio-workflo/docs/element#the-eventually-api"><code>eventually</code> API section</a> of the
<code>PageElement</code> guide.</p>
<h2><a class="anchor" aria-hidden="true" id="the-valuepageelementgroup-class"></a><a href="#the-valuepageelementgroup-class" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The <code>ValuePageElementGroup</code> Class</h2>
<h3><a class="anchor" aria-hidden="true" id="overview-and-objective-1"></a><a href="#overview-and-objective-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Overview and Objective</h3>
<p>If you want a group to manage page elements that are derived from the
<code>ValuePageElement</code> class, like in the case of HTML forms, you need to use a <code>ValuePageElementGroup</code> instead of a <code>PageElementGroup</code>.</p>
<p>The <code>ValuePageElementGroup</code> class adds the methods <code>getValue</code> and <code>setValue</code>
to set and retrieve the values of all page nodes managed by the group. Furthermore,
its <code>currently</code>, <code>wait</code> and <code>eventually</code> APIs include the state check functions
<code>hasValue</code>, <code>containsValue</code> and <code>hasAnyValue</code> to wait for or check if some or all
managed page nodes have certain expected values.</p>
<h3><a class="anchor" aria-hidden="true" id="example-definition-of-a-form"></a><a href="#example-definition-of-a-form" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Example Definition of a Form</h3>
<p><em>Please note that the following code is meant for demonstrative purposes only.
In a real use case, a group used to represent an HTML form usually only
manages different <code>ValuePageElement</code> classes and does not contain a
<code>ValuePageElementList</code>, <code>ValuePageElementMap</code> or a nested <code>ValuePageElementGroup</code>.
However, from a purely technical perspective, this would be possible.</em></p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> feed = <span class="hljs-keyword">new</span> FeedPage();

<span class="hljs-keyword">const</span> container = stores.pageNode.Element(
  xpath(<span class="hljs-string">'//div'</span>).id(<span class="hljs-string">'groupContainer'</span>)
);

<span class="hljs-keyword">const</span> form = stores.pageNode.ValueGroup({
  <span class="hljs-keyword">get</span> email() {
    <span class="hljs-keyword">return</span> container.$.Textfield(
      xpath(<span class="hljs-string">'//div'</span>).attribute(<span class="hljs-string">'role'</span>, <span class="hljs-string">'textfield'</span>).id(<span class="hljs-string">'username'</span>)
    );
  },
  <span class="hljs-keyword">get</span> acceptTerms() {
    <span class="hljs-keyword">return</span> container.$.Checkbox(
      xpath(<span class="hljs-string">'//div'</span>).attribute(<span class="hljs-string">'role'</span>, <span class="hljs-string">'checkbox'</span>).id(<span class="hljs-string">'acceptTerms'</span>)
    );
  },
  <span class="hljs-keyword">get</span> country() {
    <span class="hljs-keyword">return</span> container.$.Dropdown(
      xpath(<span class="hljs-string">'//div'</span>).attribute(<span class="hljs-string">'role'</span>, <span class="hljs-string">'dropdown'</span>).id(<span class="hljs-string">'country'</span>)
    );
  },
  <span class="hljs-keyword">get</span> label() {
    <span class="hljs-keyword">return</span> container.$.Element(
      xpath(<span class="hljs-string">'//label'</span>)
    );
  },
  <span class="hljs-keyword">get</span> inputList() {
    <span class="hljs-keyword">return</span> container.$.InputList(
      xpath(<span class="hljs-string">'//input'</span>).classContains(<span class="hljs-string">'dynamicMetadata'</span>)
    );
  },
  <span class="hljs-keyword">get</span> inputMap() {
    <span class="hljs-keyword">return</span> container.$.InputMap(
      xpath(<span class="hljs-string">'//input'</span>), {
        identifier: {
          mappingObject: {
            username: <span class="hljs-string">'username'</span>,
            password: <span class="hljs-string">'password'</span>,

          },
          mappingFunc: <span class="hljs-function">(<span class="hljs-params">baseSelector, value</span>) =&gt;</span> xpath(baseSelector).id(value)
        }
      }
    );
  },
  <span class="hljs-keyword">get</span> nestedForm() {
    <span class="hljs-keyword">return</span> container.$.ValueGroup({
      <span class="hljs-keyword">get</span> subscribe() {
        <span class="hljs-keyword">return</span> container.$.Checkbox(
          xpath(<span class="hljs-string">'//div'</span>).attribute(<span class="hljs-string">'role'</span>, <span class="hljs-string">'checkbox'</span>).id(<span class="hljs-string">'acceptTerms'</span>)
        );
      },
    });
  }
});
</code></pre>
<p>Please notice that all page nodes of our <code>ValuePageElementGroup</code>, except for
the <code>label</code> page element, are either derived from <code>ValuePageElement</code> or a class
that manages a collection of <code>ValuePageElement</code> instances, like <code>ValuePageElementList</code>
and <code>ValuePageElementMap</code>. This means that all page nodes, except for <code>label</code>,
support the methods <code>setValue()</code> and <code>getValue()</code> as well as <code>hasValue()</code>,
<code>containsValue()</code> and <code>hasAnyValue()</code> which are defined on the <code>currently</code>,
<code>wait</code> and <code>eventually</code> APIs of the respective page nodes.</p>
<p>So why does our <code>form</code> include a <code>label</code> page element that is not derived
from <code>ValuePageElement</code> and does therefore not implement the <code>setValue()</code>
and <code>getValue()</code> methods? Well, even though all <code>value</code> related methods are
not supported, other state retrieval, state check and action functions still
also work with the <code>label</code> page element.</p>
<p>This means that you can call functions like <code>click()</code>, <code>getText()</code> or
<code>currently.isVisible()</code> on each page node of our <code>form</code> group, whereas
other methods like <code>setValue()</code> can only be invoked on these page nodes
which are derived from the <code>ValuePageElement</code> class are which manage instances
of <code>ValuePageElement</code> classes.</p>
<p>In the next section of this guide that shows you how to set the values of our
form's page nodes, you'll also see what happens of we try to set a value for
our <code>label</code> page element which does not support this operation.</p>
<h3><a class="anchor" aria-hidden="true" id="setting-form-values"></a><a href="#setting-form-values" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Setting Form Values</h3>
<p>To set the values of our <code>form</code> group, we need to invoke its <code>setValue()</code> function:</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">const</span> enteredValues: Workflo.PageNode.ExtractValueStateChecker&lt;(<span class="hljs-keyword">typeof</span> form)[<span class="hljs-string">'$'</span>]&gt; = {
  email: <span class="hljs-string">'john@doe.com'</span>,
  acceptTerms: <span class="hljs-literal">true</span>,
  country: <span class="hljs-string">'Nepal'</span>,
  label: <span class="hljs-number">123</span>,
  inputList: [<span class="hljs-string">'FirstListValue'</span>, <span class="hljs-string">'SecondListValue'</span>],
  inputMap: {
    username: <span class="hljs-string">'johnDoe'</span>,
    password: <span class="hljs-string">'soSafe1234'</span>
  },
  nestedForm: {
    subscribe: <span class="hljs-literal">false</span>
  }
};

form.setValue(enteredValues);
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="declaring-the-type-of-our-form-s-values"></a><a href="#declaring-the-type-of-our-form-s-values" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Declaring the type of our form's values</h4>
<p>In the example above, we defined the values that we want to use to fill in our
form in the <code>enteredValues</code> variable. To find out which type our <code>enteredValues</code>
variable needs to have in order to be compatible with the <code>setValue()</code> function,
we can hover over the <code>setValue()</code> function and VS Code will show us the type
information for this function (alternatively, we can also hold Ctrl and click
on the function name to jump to its declaration):</p>
<p><img src="/wdio-workflo/docs/assets/group_extract.png" alt="How to extract the type of the `values` parameter of `setValue()`"></p>
<p>In the type information popup, we can see that the type of our <code>enteredValues</code>
needs to be <code>Workflo.PageNode.ExtractValueStateChecker</code>. Each of wdio-workflo's
<code>ExtractXXX</code> types takes one type parameter: the type of the content of a
<code>PageElementGroup</code>. To retrieve the content type, we can use the <code>typeof</code> operator
to get the type of our <code>form</code> group and then access it's content via the <code>$</code> accessor:
<code>(typeof form)['$']</code>.</p>
<h4><a class="anchor" aria-hidden="true" id="skipping-the-setvalue-function-for-certain-page-nodes"></a><a href="#skipping-the-setvalue-function-for-certain-page-nodes" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Skipping the <code>setValue()</code> function for certain page nodes</h4>
<p>Although the above code example defines values for all page nodes of our group that
support the <code>setValue()</code> method, we do not need to do so. We could also only
provide values for some, or even only one page node. In this case, the invocation
of the <code>setValue()</code> method will be skipped for all page nodes for which we
did not provide values:</p>
<pre><code class="hljs css language-typescript"><span class="hljs-comment">// Invokes `setValue()` on the `email` and `acceptTerms` page nodes only.</span>
form.setValue({
  email: <span class="hljs-string">'john@doe.com'</span>,
  acceptTerms: <span class="hljs-literal">true</span>
});
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="trying-to-set-a-value-on-a-page-node-not-derived-from-valuepageelement"></a><a href="#trying-to-set-a-value-on-a-page-node-not-derived-from-valuepageelement" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Trying to set a value on a page node not derived from <code>ValuePageElement</code></h4>
<p>You might have noticed that our <code>setValue()</code> code example sets the values of all
page nodes except for the <code>label</code> page element. This is due to the fact that
<code>label</code> is not derived from <code>ValuePageElement</code> and therefore does not implement
the <code>setValue()</code> method. Wdio-workflo prevents you from accidentally setting
a value for <code>label</code> by setting the type of the <code>label</code> property of our <code>enteredValues</code>
object to <code>never</code>. So no matter which can of value you try to set for <code>label</code>,
TypeScript will always throw a compile error:</p>
<p><img src="/wdio-workflo/docs/assets/group_label_error.png" alt="Trying to set a value for a `PageElement`"></p>
<p><img src="/wdio-workflo/docs/assets/group_label_error_full.png" alt="The type of the value of a `PageElement` is `never`"></p>
<h3><a class="anchor" aria-hidden="true" id="retrieving-form-values"></a><a href="#retrieving-form-values" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Retrieving Form Values</h3>
<p>To retrieve the values of our <code>form</code> group, we need to invoke its <code>getValue()</code>
method:</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">const</span> retrievedValues = form.getValue();

<span class="hljs-comment">// `retrievedValues` contains:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// {</span>
<span class="hljs-comment">//   email: 'john@doe.com',</span>
<span class="hljs-comment">//   acceptTerms: true,</span>
<span class="hljs-comment">//   country: 'Nepal',</span>
<span class="hljs-comment">//   inputList: ['FirstListValue', 'SecondListValue'],</span>
<span class="hljs-comment">//   inputMap: {</span>
<span class="hljs-comment">//     username: 'johnDoe',</span>
<span class="hljs-comment">//     password: 'soSafe1234'</span>
<span class="hljs-comment">//   },</span>
<span class="hljs-comment">//   nestedForm: {</span>
<span class="hljs-comment">//     subscribe: false</span>
<span class="hljs-comment">//   }</span>
<span class="hljs-comment">// };</span>
</code></pre>
<p>The result of the <code>getValue()</code> method is an object whose structure equals
the structure of the group`s content. However, the page node instances are
replaced by their values.</p>
<p>If we do not need to retrieve the values of all page nodes, we can skip
the <code>getValue()</code> function invocation for certain page nodes by using a
<a href="#filter-masks">filter mask</a>:</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">const</span> filteredRetrievedValues = form.getValue({
  email: <span class="hljs-literal">false</span>,
  country: <span class="hljs-literal">true</span>,
  inputList: [<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>],
  inputMap: {
    password: <span class="hljs-literal">true</span>
  },
  nestedForm: {
    subscribe: <span class="hljs-literal">false</span>
  }
});

<span class="hljs-comment">// `filteredRetrievedValues` contains:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// {</span>
<span class="hljs-comment">//   email: undefined,</span>
<span class="hljs-comment">//   acceptTerms: undefined,</span>
<span class="hljs-comment">//   country: 'Nepal',</span>
<span class="hljs-comment">//   inputList: ['FirstListValue', undefined],</span>
<span class="hljs-comment">//   inputMap: {</span>
<span class="hljs-comment">//     username: undefined,</span>
<span class="hljs-comment">//     password: 'soSafe1234'</span>
<span class="hljs-comment">//   },</span>
<span class="hljs-comment">//   nestedForm: {</span>
<span class="hljs-comment">//     subscribe: undefined</span>
<span class="hljs-comment">//   }</span>
<span class="hljs-comment">// };</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="checking-form-values"></a><a href="#checking-form-values" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Checking Form Values</h3>
<p>To check the values of our <code>form</code> group, we could invoke the <code>hasValue()</code>,
<code>containsValue()</code> or <code>hasAnyValue()</code> functions defined on the <code>currently</code> and
<code>eventually</code> APIs of <code>ValuePageElementGroup</code> and then use the <code>expect()</code>
matcher to check if the resulting value is <code>true</code>.</p>
<p>However, this way the error messages thrown if the expectation fails are not
very meaningful.</p>
<p>A much better way to check if our <code>form</code> group's values equal certain expected
values is to pass our <code>form</code> group to <code>expectGroup</code> and invoke its
<code>toHaveValue()</code> or <code>toEventuallyHaveValue()</code> expectation matchers. This will
give us much more detailed error message in case the expected values do not
match the actual values of our <code>form</code>:</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">const</span> expectedValues: Workflo.PageNode.ExtractValueStateChecker&lt;(<span class="hljs-keyword">typeof</span> form)[<span class="hljs-string">'$'</span>]&gt; = {
  email: <span class="hljs-string">'john@doe.com'</span>,
  country: <span class="hljs-string">'Nepal'</span>,
  inputMap: {
    username: <span class="hljs-string">'johnDoe'</span>
  },
  nestedForm: { subscribe: <span class="hljs-literal">true</span> }
};

<span class="hljs-comment">// If this expectation fails, the error message will simply say:</span>
<span class="hljs-comment">// 'Expected false to be true'.</span>
expect(
  form.eventually.hasValue(expectedValues, { timeout: <span class="hljs-number">3000</span> })
).toBe(<span class="hljs-literal">true</span>);

<span class="hljs-comment">// If this expectation fails, the error message will tell you exactly</span>
<span class="hljs-comment">// which actual value did not match the expected value, print both values</span>
<span class="hljs-comment">// and the XPath of the respective page node.</span>
expectGroup(form).toEventuallyHaveValue(expectedValues, { timeout: <span class="hljs-number">3000</span> });
</code></pre>
<p>Please note that in the example above, the timeout of 3 seconds will be applied to
each &quot;leaf page element&quot; separately, so the total amount of time needed to complete
these checks can substantially exceed 3 seconds.</p>
<h2><a class="anchor" aria-hidden="true" id="no-need-for-customization"></a><a href="#no-need-for-customization" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>No Need For Customization</h2>
<p>Unlike a <code>PageElementList</code> or a <code>PageElementMap</code>, which are &quot;bound&quot; to a particular
<code>PageElement</code> class because they can only manage <code>PageElement</code> instances that are all
of the same class, a <code>PageElementGroup</code> can manage any combination of <code>PageNode</code>
instances of various classes. Therefore, we usually don't need to create custom <code>PageElementGroup</code> classes and we also don't have to add additional group factory
methods to a <code>PageNodeStore</code>. Instead, we can simply use the two factory
methods <code>ElementGroup()</code> and <code>ValueGroup()</code>, which already ship with wdio-workflo,
in pretty much any situation.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/wdio-workflo/docs/map"><span class="arrow-prev">← </span><span>Map</span></a><a class="docs-next button" href="/wdio-workflo/docs/store"><span>Store</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#overview-and-objective">Overview and Objective</a></li><li><a href="#creating-a-pageelementgroup">Creating a <code>PageElementGroup</code></a><ul class="toc-headings"><li><a href="#elementgroup-factory-method"><code>ElementGroup()</code> Factory Method</a></li><li><a href="#type-parameters">Type Parameters</a></li><li><a href="#constructor">Constructor</a></li><li><a href="#content-object"><code>content</code> Object</a></li></ul></li><li><a href="#accessing-group-elements">Accessing Group Elements</a></li><li><a href="#state-functions">State Functions</a><ul class="toc-headings"><li><a href="#pageelementgroup-example-code"><code>PageElementGroup</code> Example Code</a></li><li><a href="#composite-pattern">Composite Pattern</a></li><li><a href="#state-retrieval-functions">State Retrieval Functions</a></li><li><a href="#action-functions">Action Functions</a></li><li><a href="#state-check-functions">State Check Functions</a></li><li><a href="#filter-masks">Filter Masks</a></li></ul></li><li><a href="#waiting-mechanisms">Waiting Mechanisms</a><ul class="toc-headings"><li><a href="#implicit-waiting">Implicit Waiting</a></li><li><a href="#explicit-waiting-currently-wait-and-eventually">Explicit Waiting: <code>currently</code>, <code>wait</code> and <code>eventually</code></a></li><li><a href="#the-currently-api">The <code>currently</code> API</a></li><li><a href="#the-wait-api">The <code>wait</code> API</a></li><li><a href="#the-eventually-api">The <code>eventually</code> API</a></li></ul></li><li><a href="#the-valuepageelementgroup-class">The <code>ValuePageElementGroup</code> Class</a><ul class="toc-headings"><li><a href="#overview-and-objective-1">Overview and Objective</a></li><li><a href="#example-definition-of-a-form">Example Definition of a Form</a></li><li><a href="#setting-form-values">Setting Form Values</a></li><li><a href="#retrieving-form-values">Retrieving Form Values</a></li><li><a href="#checking-form-values">Checking Form Values</a></li></ul></li><li><a href="#no-need-for-customization">No Need For Customization</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/wdio-workflo/" class="nav-home"><img src="/wdio-workflo/img/logo.svg" alt="Wdio-Workflo" width="66" height="58"/></a><div><h5>Docs</h5><a href="/wdio-workflo/docs/setup">Guides</a><a href="https://github.com/flohil/wdio-workflo-example">Examples</a><a href="/wdio-workflo/apiDoc">API Reference</a></div><div></div><div><h5>More</h5><a href="https://github.com/flohil/wdio-workflo">GitHub</a><a class="github-button" href="https://github.com/flohil/wdio-workflo" data-icon="octicon-star" data-count-href="/facebook/docusaurus/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><section class="copyright">Copyright © 2019 Florian Hilbinger</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '06ded81a116783d66e7d32d28ee42d05',
                indexName: 'wdio-workflo',
                inputSelector: '#search_input_react'
              });
            </script></body></html>